/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package mendixlabs.mendixgradleplugin

import mendixlabs.mendixgradleplugin.tasks.*
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.distribution.DistributionContainer
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.JavaExec

abstract class MxGradlePluginExtension {
    abstract val mendixVersion: Property<String>
    abstract val mprFileName: Property<String>
    abstract val installPath: Property<String>

    init {
        mprFileName.convention("App.mpr")
    }

}

const val PLUGIN_GROUP_MX = "mendix"

/**
 * Mendix Gradle Plugin
 *
 * Interact with your Mendix project using Gradle commands. The
 * plugin handles getting the correct version installed on the
 * machine when not available and can build a self-contained
 * distribution.
 *
 */
@Suppress("unused")
class MendixGradlePlugin: Plugin<Project> {

    private val appBuildDir = "app"

    override fun apply(project: Project) {
        // add plugins to the project
        val extension = project.extensions.create("mendix", MxGradlePluginExtension::class.java)
        project.plugins.apply("distribution")

        registerTasks(project)

        project.afterEvaluate { p ->
            if (p.hasProperty("mendixVersion")) {
                extension.mendixVersion.set(p.properties.get("mendixVersion").toString())
            }
            if (p.hasProperty("mendixInstallPath")) {
                extension.installPath.set(p.properties.get("mendixInstallPath").toString())
            }
        }

    }

    fun registerTasks(project: Project) {
        val extension = project.extensions.getByType<MxGradlePluginExtension>(MxGradlePluginExtension::class.java)

        // -------------------------------------------------------------------------------------------------------------
        // Project helpers
        // -------------------------------------------------------------------------------------------------------------
        project.tasks.register<GetMendixVersion>("mxGetVersion", GetMendixVersion::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Read the Mendix version from the projects MPR file."

            task.mprFilename.set(project.layout.projectDirectory.file(extension.mprFileName))
        }

        project.tasks.register<ListVersions>("mxListVersions", ListVersions::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "List available Mendix versions"
        }

        // -------------------------------------------------------------------------------------------------------------
        // Wrap mx tooling
        // -------------------------------------------------------------------------------------------------------------
        project.tasks.register<MxCommand>("mx", MxCommand::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Call mx(.exe) for configured mendixVersion."

            task.dependsOn("mxEnsureModeler")
            task.outputs.upToDateWhen { false }

            task.tool.set("mx")
            task.mendixVersion.set(extension.mendixVersion)
        }

        project.tasks.register<MxCommand>("mxutil", MxCommand::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Call mxutil(.exe) for configured mendixVersion."

            task.dependsOn("mxEnsureModeler")
            task.outputs.upToDateWhen { false }

            task.tool.set("mxutil")
            task.mendixVersion.set(extension.mendixVersion)
        }

        project.tasks.register<Mxbuild>("mxbuild", Mxbuild::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Call mxbuild(.exe) for configured mendixVersion."

            task.dependsOn("mxEnsureModeler")

            task.mendixVersion.set(extension.mendixVersion)
            task.mpr.set(project.layout.projectDirectory.file(extension.mprFileName))

            // watch these files and folders to make mxbuild incremental
            // file list based on Mendix 10
            task.projectFiles.from(
                    project.layout.projectDirectory.files(
                            extension.mprFileName.get(),
                            "javascriptsource",
                            "javasource",
                            "mlsource",
                            "modules",
                            "ressources",
                            "templates",
                            "theme",
                            "themesource",
                            "userlib",
                            "widgets"
                    )
            )
            task.outputPath.set(project.layout.buildDirectory.dir(appBuildDir))

            task.doLast {
                // create a .files file to copy it into the distribution later,
                // without it the Mendix app won't start.
                project.layout.buildDirectory.file("${appBuildDir}/.files").get().asFile.createNewFile()
            }
        }

        // -------------------------------------------------------------------------------------------------------------
        // Convenience tasks
        // -------------------------------------------------------------------------------------------------------------
        project.tasks.register<MxCommand>("mxInit", MxCommand::class.java) { task ->
            val appName = extension.mprFileName.map { s -> s.replace(".mpr", "") }

            task.group = PLUGIN_GROUP_MX
            task.description = "Create a new Mendix project using the available 'mendix' config."

            task.dependsOn("mxEnsureModeler")

            task.outputs.upToDateWhen { project.file(extension.mprFileName).exists() }

            task.tool.set("mx")
            task.mendixVersion.set(extension.mendixVersion)
            task.args.set(listOf("create-project",
                    "--app-name", appName.get(),
                    "--output-dir", project.rootDir.absolutePath))
        }

        project.tasks.register<MxCommand>("mxDumpMpr", MxCommand::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Dump MPR to JSON"

            task.dependsOn("mxEnsureModeler")

            task.tool.set("mx")
            task.mendixVersion.set(extension.mendixVersion)
            task.watch.from(project.layout.projectDirectory.file(extension.mprFileName))

            // make a list of providers so that extension.mprFileName evaluates late
            val args = project.objects.listProperty(String::class.java)
            args.add("dump-mpr")
            args.add(extension.mprFileName)
            task.args.set(args)

            task.outputType.set(OutputType.FILE)
            task.outputFile.set(project.layout.buildDirectory.file("${appBuildDir}/${project.name}.json"))
        }

        project.tasks.register<GenerateDockerFile>("mxGenerateDockerfile", GenerateDockerFile::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Generate a Dockerfile for this project."

            task.dependsOn("installMxDist")
        }

        // -------------------------------------------------------------------------------------------------------------
        // Tasks for operations on project
        // -------------------------------------------------------------------------------------------------------------
        project.tasks.register<WriteConfigs>("mxWriteConfigs", WriteConfigs::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Write config files based on configuration in the project MPR"

            task.dependsOn("mxbuild", "mxDumpMpr")

            val mprJson = project.tasks.getByName("mxDumpMpr").outputs.files.singleFile
            task.mda.set(project.layout.buildDirectory.file("${appBuildDir}/${project.name}.mda"))
            task.mprAsJson.set(mprJson)
            task.outputPath.set(project.layout.buildDirectory.dir(appBuildDir))
        }

        project.tasks.register<Copy>("mxDeployMda", Copy::class.java) {task ->
            task.from(project.zipTree(project.layout.buildDirectory.file("${appBuildDir}/${project.name}.mda")))
            task.into(project.layout.buildDirectory.dir("deployment"))

            task.dependsOn("mxbuild", "mxWriteConfigs")

            task.doLast {
                project.mkdir(project.layout.buildDirectory.dir("deployment/data/files"))
            }
        }

        project.tasks.register<JavaExec>("mxRun", JavaExec::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Run the Mendix project"

            task.dependsOn("mxEnsureRuntime", "mxWriteConfigs", "mxDeployMda")

            task.classpath(extension.mendixVersion.map { e -> "build/modeler/${e}/runtime/launcher/runtimelauncher.jar" }.get())
            task.jvmArgs(extension.mendixVersion.map { e -> listOf("-DMX_INSTALL_PATH=build/modeler/${e}") }.get())

            val args = listOf(
                project.tasks.getByName("mxDeployMda").outputs.files.singleFile.absolutePath,
                project.layout.buildDirectory.file(appBuildDir + "/Default.conf").get().asFile.absolutePath
            )
            task.args(args)

        }

        // -------------------------------------------------------------------------------------------------------------
        // Download and unpack Mxbuild tasks
        // -------------------------------------------------------------------------------------------------------------
        project.tasks.register<CDNDownload>("mxInternalDownloadMxbuild", CDNDownload::class.java) { task ->
            task.distribution.set(DistributionType.MODELER)
            task.mendixVersion.set(extension.mendixVersion)

            // we'll assume that a project is only used on one operating system
            task.dest.set(project.layout.buildDirectory.file(
                extension.mendixVersion.map { e -> "modeler/${constructMxbuildFilename(DistributionType.MODELER, e)}" }
            ))
        }

        project.tasks.register<Copy>("mxInternalUnpackMxbuild", Copy::class.java) { task ->
            task.dependsOn("mxInternalDownloadMxbuild")

            val mxbuildDistribtionFile = project.tasks.getByName("mxInternalDownloadMxbuild").outputs.files.singleFile
            task.from(project.tarTree(project.resources.gzip(mxbuildDistribtionFile)))
            task.into(project.layout.buildDirectory.dir(extension.mendixVersion.map { e-> "modeler/${e}" } ))
        }

        project.tasks.register("mxEnsureModeler") { task ->
            val mxVersion = extension.mendixVersion.get()
            task.group = PLUGIN_GROUP_MX
            task.description = "Get MxBuild if configured version is not available locally."

            val toolFinder = ToolFinderBuilder()
                    .withMendixVersion(mxVersion)
                    .withProject(project)
                    .build()
            if (!toolFinder.isModelerInstalled()) {
                task.logger.lifecycle("modeler is not installed")
                task.dependsOn("mxInternalUnpackMxbuild")
                task.mustRunAfter("mxInternalUnpackMxbuild")
            } else {
                task.logger.lifecycle("modeler is installed")
            }
        }

        // -------------------------------------------------------------------------------------------------------------
        // Download and unpack Runtime tasks
        // -------------------------------------------------------------------------------------------------------------
        project.tasks.register<CDNDownload>("mxInternalDownloadRuntime", CDNDownload::class.java) { task ->
            task.distribution.set(DistributionType.RUNTIME)
            task.mendixVersion.set(extension.mendixVersion)

            task.dest.set(project.layout.buildDirectory.file(
                    extension.mendixVersion.map { e -> "modeler/${constructMxbuildFilename(DistributionType.RUNTIME, e)}" }
            ))
        }

        project.tasks.register<Copy>("mxInternalUnpackRuntime", Copy::class.java) { task ->
            task.dependsOn("mxInternalDownloadRuntime")

            task.mustRunAfter("mxInternalUnpackMxbuild")

            val runtimeDistribtionFile = project.tasks.getByName("mxInternalDownloadRuntime").outputs.files.singleFile
            task.from(project.tarTree(project.resources.gzip(runtimeDistribtionFile)))
            task.into(project.layout.buildDirectory.dir("modeler/"))
        }

        project.tasks.register("mxEnsureRuntime").configure { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Get Runtime if configured version is not available locally."

            val toolFinder = ToolFinderBuilder()
                .withMendixVersion(extension.mendixVersion.get())
                .withProject(project)
                .build();
            if (!toolFinder.isRuntimeInstalled()) {
                task.logger.lifecycle("runtime is not installed")
                task.dependsOn("mxInternalUnpackRuntime")
                task.mustRunAfter("mxInternalUnpackRuntime")
            } else {
                task.logger.lifecycle("runtime is installed")
            }
        }


        // -------------------------------------------------------------------------------------------------------------
        // Configure the distribution plugin
        // -------------------------------------------------------------------------------------------------------------
        project.tasks.register<GenerateStartScripts>("mxStartScripts", GenerateStartScripts::class.java) { task ->
            task.group = PLUGIN_GROUP_MX
            task.description = "Generate start scripts for the Mendix app."
        }

        // adding a custom distribution creates tasks
        // mxDistZip
        // mxDistTar
        // installMxDist
        val distributions = project.extensions.getByType(DistributionContainer::class.java)
        distributions.register("mx") { dist ->
            dist.distributionBaseName.set(project.name)

            dist.contents { spec ->
                spec.into("app") { appSpec ->
                    appSpec.from(project.zipTree(project.layout.buildDirectory.file("${appBuildDir}/${project.name}.mda")))
                }

                // make sure we can actually run this app
                spec.into("app/data/files") { dataSpec ->
                    dataSpec.from(project.layout.buildDirectory.file("app/.files"))
                }

                spec.into("bin") { binSpec ->
                    binSpec.from(project.layout.buildDirectory.dir("scripts"))
                }

                spec.into("etc") { etcSpec ->
                    etcSpec.from(project.tasks.getByName("mxWriteConfigs").outputs.files.singleFile) {
                        it.include { f -> f.file.name.endsWith(".conf")}
                    }
                }

                spec.into("runtime") { runtimeSpec ->
                    val runtimeDir = extension.mendixVersion.map { version ->
                        val toolFinder = ToolFinderBuilder()
                            .withMendixVersion(version)
                            .withProject(project)
                            .build()
                        toolFinder.getRuntimeLocation()
                    }
                    runtimeSpec.from(runtimeDir)
                }
            }
        }

        project.tasks.named("mxDistZip") { task ->
            task.dependsOn("mxEnsureRuntime", "mxbuild", "mxStartScripts", "mxWriteConfigs")
        }

        project.tasks.named("installMxDist") { task ->
            task.dependsOn("mxEnsureRuntime", "mxbuild", "mxStartScripts", "mxWriteConfigs")
        }

        listOf("mxDistTar", "startScripts").forEach { e -> project.tasks.named(e) { task -> task.enabled = false} }
    }

}
